================================================================================
CHUNK 5 OF 5
================================================================================

========================================
File: ./examples/eg_2_coingecko.py
========================================
from webpath import WebPath

def check_crypto_prices_with_shortcuts():
    print("Testing JSON Shortcuts with Real CoinGecko API\n")
    
    api = WebPath("https://api.coingecko.com/api/v3").with_logging()
    
    prices = api / "simple" / "price"
    response = prices.with_query(
        ids="bitcoin,ethereum,cardano",
        vs_currencies="usd",
        include_24hr_change="true"
    ).get()

    print("Using .find() method:")
    coins = ["bitcoin", "ethereum", "cardano"]
    for coin in coins:
        price = response.find(f"{coin}.usd")
        change = response.find(f"{coin}.usd_24h_change")
        direction = "UP" if change > 0 else "DOWN"
        print(f"{coin}: ${price:,.2f} {direction} {change:.1f}%")
    
    print("\nUsing .find_all() with wildcards:")
    all_prices = response.find_all("*.usd")
    all_changes = response.find_all("*.usd_24h_change")
    coin_names = list(response.json_data.keys())
    
    for i, coin in enumerate(coin_names):
        price = all_prices[i]
        change = all_changes[i]
        direction = "UP" if change > 0 else "DOWN"
        print(f"   {coin}: ${price:,.2f} {direction} {change:.1f}%")
    
    print("\nUsing .extract() for specific coins:")
    btc_price, btc_change = response.extract("bitcoin.usd", "bitcoin.usd_24h_change")
    eth_price, eth_change = response.extract("ethereum.usd", "ethereum.usd_24h_change")
    
    print(f" Bitcoin: ${btc_price:,.2f} ({'UP' if btc_change > 0 else 'DOWN'} {btc_change:.1f}%)")
    print(f" Ethereum: ${eth_price:,.2f} ({'UP' if eth_change > 0 else 'DOWN'} {eth_change:.1f}%)")
    
    print("\nUsing .search() to find all USD data:")
    usd_values = response.search("usd")
    print(f" Found {len(usd_values)} USD values")
    
    print("\nUsing .has_path() to check data availability:")
    print(f" Has Bitcoin data? {response.has_path('bitcoin')}")
    print(f" Has Bitcoin USD price? {response.has_path('bitcoin.usd')}")
    print(f" Has volume data? {response.has_path('bitcoin.usd_24h_vol')}")
    print(f"Has Dogecoin data? {response.has_path('dogecoin')}")
    
    print("\nUsing defaults for missing data:")
    doge_price = response.find("dogecoin.usd", default="Not requested")
    btc_volume = response.find("bitcoin.usd_24h_vol", default="Not available")
    print(f" Dogecoin price: {doge_price}")
    print(f" Bitcoin volume: {btc_volume}")

def test_complex_api():
    print("\nTesting with detailed Bitcoin data:")
    
    try:
        api = WebPath("https://api.coingecko.com/api/v3").with_logging()
        response = (api / "coins" / "bitcoin").get()
        
        name = response.find("name")
        symbol = response.find("symbol")
        current_price = response.find("market_data.current_price.usd")
        market_cap = response.find("market_data.market_cap.usd")
        total_supply = response.find("market_data.total_supply")
        
        print(f" Coin: {name} ({symbol.upper()})")
        print(f" Price: ${current_price:,.2f}")
        print(f" Market Cap: ${market_cap:,.0f}")
        print(f" Total Supply: {total_supply:,.0f}")
        
        all_prices = response.find_all("market_data.current_price.*")
        print(f" Found prices in {len(all_prices)} currencies")
        
        eur_price = response.find("market_data.current_price.eur")
        gbp_price = response.find("market_data.current_price.gbp")
        
        if eur_price: print(f" EUR: €{eur_price:,.2f}")
        if gbp_price: print(f" GBP: £{gbp_price:,.2f}")
        
    except Exception as e:
        print(f"API test failed: {e}")

if __name__ == "__main__":
    check_crypto_prices_with_shortcuts()
    test_complex_api()
========================================
File: ./tests/test_download.py
========================================
import requests_mock, hashlib
from webpath import WebPath
import pytest
import requests_mock

def test_download(tmp_path):
    data      = b"x" * 1024
    checksum  = hashlib.sha256(data).hexdigest()
    dest      = tmp_path / "x.bin"

    with requests_mock.Mocker() as m:
        m.register_uri("GET", "https://d.com/x", content=data, headers={"content-length": "1024"})
        WebPath("https://d.com/x").download(dest, progress=False, checksum=checksum)
    
    assert dest.read_bytes() == data

def test_download_bad_checksum(tmp_path):
    data = b"abcdef"
    good = hashlib.sha256(data).hexdigest()
    bad  = "deadbeef" * 8
    path = tmp_path / "d.bin"

    with requests_mock.Mocker() as m:
        m.get("https://x/x", content=data, headers={"content-length": str(len(data))})
        with pytest.raises(ValueError):
            WebPath("https://x/x").download(path, checksum=bad, progress=False)
    assert not path.exists()

def test_cache_excludes_sensitive_headers():
    import tempfile
    from pathlib import Path
    
    with tempfile.TemporaryDirectory() as tmpdir:
        cache_dir = Path(tmpdir)
        
        with requests_mock.Mocker() as m:
            m.get("https://api.example.com/secret", 
                  text="sensitive data",
                  headers={
                      "Authorization": "Bearer secret-token",
                      "X-API-Key": "api-key-123",
                      "Content-Type": "application/json"
                  })
            
            url = WebPath("https://api.example.com/secret").with_cache(cache_dir=cache_dir)
            resp = url.get()
            
            cache_files = list(cache_dir.glob("*.json"))
            assert len(cache_files) == 1
            
            import json
            with cache_files[0].open() as f:
                cached = json.load(f)
            
            headers = cached["headers"]
            lower_headers = {k.lower(): v for k, v in headers.items()}
            assert "authorization" not in lower_headers
            assert "x-api-key" not in lower_headers
            assert "content-type" in lower_headers

def test_pagination_max_pages_limit():
    with requests_mock.Mocker() as m:
        for i in range(5):
            m.get(f"https://api.com/page{i}", json={
                "data": [f"item{i}"],
                "next": f"https://api.com/page{i+1}"
            })
        
        resp = WebPath("https://api.com/page0").get()
        pages = list(resp.paginate(max_pages=3))
        
        assert len(pages) == 3
        assert m.call_count >= 3

# skipping the interrupted download test for now
@pytest.mark.skip(reason="Complex requests_mock streaming issue")
def test_download_interrupted_cleanup(tmp_path):
    pass
========================================
File: ./webpath/cli.py
========================================
from __future__ import annotations
import sys
import json
import typer
from pathlib import Path
from rich import print as rprint
from webpath.core import WebPath

app = typer.Typer(add_completion=False, help="Tiny CLI gateway for webpath")

@app.command()
def join(base: str, *segments: str):     # pragma: no skylos
    """Echo base / seg1 / seg2 ..."""
    url = WebPath(base)
    for seg in segments:
        url = url / seg
    rprint(str(url))

@app.command()
def get(
    url: str,
    pretty: bool = typer.Option(False, "--pretty", "-p"),
    retries: int = typer.Option(0, "--retries", "-r"),
    backoff: float = typer.Option(0.3, "--backoff", "-b"),
):
    r = WebPath(url).get(retries=retries, backoff=backoff)
    if pretty and "application/json" in r.headers.get("content-type", ""):
        rprint(json.dumps(r.json(), indent=2))
    else:
        sys.stdout.buffer.write(r.content)


@app.command()
def download(
    url: str,
    dest: Path = typer.Argument(..., exists=False, dir_okay=False, writable=True),
    retries: int = typer.Option(3, "--retries", "-r"),
    backoff: float = typer.Option(0.3, "--backoff", "-b"),
    checksum: str | None = typer.Option(None, "--checksum", "-c", help="Expected hex digest"),
):
    wp = WebPath(url)
    wp.download(dest, retries=retries, backoff=backoff, checksum=checksum)
    rprint(f"[green] * [/green] Saved to {dest}")

def _main_():
    app()

if __name__ == "__main__":
    _main_()
========================================
File: ./tests/test_security.py
========================================

import requests_mock
from webpath import WebPath

def test_ssrf_protection_disabled_by_default():
    with requests_mock.Mocker() as m:
        m.get("https://api.example.com/data", json={
            "next_url": "http://localhost:8080/internal"
        })
        
        resp = WebPath("https://api.example.com/data").get()
        result = resp / "next_url"
        assert result == "http://localhost:8080/internal"
        assert m.call_count == 1

def test_ssrf_protection_blocks_localhost():
    with requests_mock.Mocker() as m:
        m.get("https://api.example.com/data", json={
            "redirect": "http://127.0.0.1:6379/evil"
        })
        
        resp = WebPath("https://api.example.com/data").get()
        # Tneed to add _allow_auto_follow to WebPath.. for now test that it returns string instead of following
        result = resp / "redirect"
        assert result == "http://127.0.0.1:6379/evil"

def test_cache_excludes_sensitive_headers():
    """Cache should not store sensitive authentication headers"""
    import tempfile
    from pathlib import Path
    
    with tempfile.TemporaryDirectory() as tmpdir:
        cache_dir = Path(tmpdir)
        
        with requests_mock.Mocker() as m:
            m.get("https://api.example.com/secret", 
                  text="sensitive data",
                  headers={
                      "Authorization": "Bearer secret-token",
                      "X-API-Key": "api-key-123",
                      "Content-Type": "application/json"
                  })
            
            url = WebPath("https://api.example.com/secret").with_cache(cache_dir=cache_dir)
            resp = url.get()
            
            cache_files = list(cache_dir.glob("*.json"))
            assert len(cache_files) == 1
            
            import json
            with cache_files[0].open() as f:
                cached = json.load(f)
            
            headers = cached["headers"]
            assert "authorization" not in headers
            assert "x-api-key" not in headers
            assert "Content-Type" in headers
========================================
File: ./tests/test_error_handling.py
========================================

import requests_mock
from webpath import WebPath
import pytest

def test_json_parsing_error_fallback():
    with requests_mock.Mocker() as m:
        m.get("https://api.com/broken", text="{invalid json}")
        
        resp = WebPath("https://api.com/broken").get()
        # json_data should fall back to empty dict
        assert resp.json_data == {}
        
        with pytest.raises(Exception):
            resp.json()

def test_response_key_error_handling():
    """handle missing keys in JSON responses"""
    with requests_mock.Mocker() as m:
        m.get("https://api.com/data", json={"exists": "value"})
        
        resp = WebPath("https://api.com/data").get()
        
        assert resp / "exists" == "value"
        
        with pytest.raises(KeyError):
            resp / "missing"

def test_http_error_messages():
    """should provide helpful error messages"""
    with requests_mock.Mocker() as m:
        m.get("https://api.com/401", status_code=401, json={"error": "Invalid token"})
        m.get("https://api.com/429", status_code=429, headers={"Retry-After": "60"})
        
        with pytest.raises(Exception, match="Authentication failed.*Invalid token"):
            WebPath("https://api.com/401").get()
        
        with pytest.raises(Exception, match="Rate limited.*60 seconds"):
            WebPath("https://api.com/429").get()
========================================
File: ./tests/test_pagination.py
========================================

import requests_mock
from webpath import WebPath

def test_pagination_cycle_detection():
    """should detect and break pagination cycles"""
    with requests_mock.Mocker() as m:
        m.get("https://api.com/page1", json={
            "data": ["item1", "item2"],
            "next": "https://api.com/page2"
        })
        m.get("https://api.com/page2", json={
            "data": ["item3", "item4"], 
            "next": "https://api.com/page1"
        })
        
        resp = WebPath("https://api.com/page1").get()
        pages = list(resp.paginate(max_pages=10))
        
        assert len(pages) == 2
        assert m.call_count >= 2

def test_pagination_max_pages_limit():
    with requests_mock.Mocker() as m:
        for i in range(5):
            m.get(f"https://api.com/page{i}", json={
                "data": [f"item{i}"],
                "next": f"https://api.com/page{i+1}"
            })
        
        resp = WebPath("https://api.com/page0").get()
        pages = list(resp.paginate(max_pages=3))
        
        assert len(pages) == 3
        assert m.call_count >= 3
========================================
File: ./.gitignore
========================================
venv
.pytest_cache
__pycache__
*.egg-info
dist
build
